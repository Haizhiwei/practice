#restful风格

统一代码风格，便于团队开发，特别是前后端分离，面向接口开发

URI：  /资源名称/资源标识       HTTP请求方式区分对资源CRUD操作

get获取资源、post新建资源、put更新资源、delete删除资源

      	普通CRUD（uri来区分操作）       	RestfulCRUD      
  查询  	getEmp                 						emp---GET        
  添加  	addEmp?xxx             					emp---POST       
  修改  	updateEmp?id=xxx&xxx=xx			emp/{id}---PUT   
  删除  	deleteEmp?id=1         					emp/{id}---DELETE

> 看Url就知道要什么
>
> 看http method就知道干什么
> 看http status code就知道结果如何

首先要明确一点：REST 实际上只是一种设计风格，它并不是标准。（所以你可以看到网上一大堆的各种最佳实践，设计指南，但是没有人说设计标准）。[aisuhua/restful-api-design-references ・ GitHub](https://link.zhihu.com/?target=https%3A//github.com/aisuhua/restful-api-design-references)

说说几个重要的概念：

**1、REST 是面向资源的，这个概念非常重要，而资源是通过 URI 进行暴露。**
URI 的设计只要负责把资源通过合理方式暴露出来就可以了。对资源的操作与它无关，操作是通过 HTTP动词来体现，所以REST 通过 URI 暴露资源时，会强调不要在 URI 中出现动词。

```
GET /rest/api/getDogs --> GET /rest/api/dogs 获取所有小狗狗 
GET /rest/api/addDogs --> POST /rest/api/dogs 添加一个小狗狗 
GET /rest/api/editDogs/:dog_id --> PUT /rest/api/dogs/:dog_id 修改一个小狗狗 
GET /rest/api/deleteDogs/:dog_id --> DELETE /rest/api/dogs/:dog_id 删除一个小狗狗 
```

左边的这种设计，很明显不符合REST风格，上面已经说了，URI 只负责准确无误的暴露资源，而 getDogs/addDogs...已经包含了对资源的操作，这是不对的。相反右边却满足了，它的操作是使用标准的HTTP动词来体现。

**2、REST很好地利用了HTTP本身就有的一些特征，如HTTP动词、HTTP状态码、HTTP报头等等**
REST API 是基于 HTTP的，所以你的API应该去使用 HTTP的一些标准。这样所有的HTTP客户端（如浏览器）才能够直接理解你的API（当然还有其他好处，如利于缓存等等）。REST 实际上也非常强调应该利用好 HTTP本来就有的特征，而不是只把 HTTP当成一个传输层这么简单了。

HTTP动词

```
GET     获取一个资源 
POST    添加一个资源 
PUT     修改一个资源 
DELETE  删除一个资源 
```

实际上，这四个动词实际上就对应着增删改查四个操作，这就利用了HTTP动词来表示对资源的操作。

HTTP状态码

```
200 OK 
400 Bad Request 
500 Internal Server Error
```

- 所有事情都按预期正确执行完毕 - 成功
- APP 发生了一些错误 C 客户端错误
- API 发生了一些错误 C 服务器端错误

这三种状态与上面的状态码是一一对应的。

HTTP报头

```
Authorization 认证报头 
Cache-Control 缓存报头 
Cnotent-Type  消息体类型报头 
......
```

报头还有很多，不一一列举。HTTP报头是描述HTTP请求或响应的元数据，它的作用是客户端 与 服务器端进行相互通信时，告诉对方应该如何处理本次请求。

**3、超媒体**
老实说，这个词汇我到目前还有没搞得全懂。那也说说自己的理解吧，不一定准确哦，有错误希望指出。
”超媒体“ 你没听说过没关系，”超链接“ 你一定不会陌生。简单来说，”超链接“ 是实现超媒体中的一种方式。”超媒体“希望达到一种就是说在 REST API 中把所有资源给链接起来。它就犹如你打开一个网站的首页，你难道看到的只有首页吗？NO !, 不是的，你可以通过首页查看商品、查看文章、查看论坛。”超媒体“ 就是做这个事情，它利用 API 把所有资源的关系给链接起来了，你看到不会只是一个独立的资源，而是关系网中的一个资源。
”超媒体“ 有点高大上了，老实说，就算你够牛X，写出了一个非常棒的符合”超媒体“的REST API，你的用户即开发者，也不一定能够接受你这种高大上的设计。当然，我相信未来也许可以普及了。



#forward(转发)redirect(重定向)的区别#

区别：

地址栏：forward为服务器的直接跳转，客户端浏览器并不知道，地址栏内容不变（服务器内部的动作）

????????	redirect为客户端浏览器根据URL地址重新向服务器请求，地址栏变（有可能是请求的URI地址发生变化）

数据共享：forward共享浏览器传来的request

???????????????? redirect全新的request （这是服务器会向客户端发送302 状态码和新的url 301代表永久性转移 302代表暂时性转移）

运用的地方：forward用户登录后根据角色跳转页面

???????????             redirect在用户注销后跳转主页或其他页面

效率：1比2少了一次服务器请求，效率高一些

#JSP所支持的九大隐含对象：#

request 	       HttpServletRequest类的实例
response       HttpServletResponse类的实例
out 		        PrintWriter类的实例，用于把结果输出至网页上
session		HttpSession类的实例
application	ServletContext类的实例，与应用上下文有关
config		ServletConfig类的实例
pageContext	PageContext类的实例，提供对JSP页面所有对象以及命名空间的访问
page  		类似于Java类中的this关键字
Exception	Exception类的对象，代表发生错误的JSP页面中对应的异常对象

#JSP的四个作用域#

application	  在所有应用程序中有效
session		  在当前会话中有效
request		  在当前请求中有效

page		  在当前页面有效

#成员变量和局部变量的区别#

1 在类中位置不同：成员变量：在类中方法外。局部变量：在方法定义中或者方法声明上。
2 在内存中的位置不同：成员变量：在堆内存。  局部变量：在栈内存。
3 生命周期不同：成员变量：随着对象的创建而存在，随着对象的消失而消失。 局部变量：随着方法的调用而存在，随着方法的调用完毕而消失。
4 初始化值不同：成员变量：有默认值初始化。局部变量：没有默认值初始化，必须定义，赋值，然后才能使用。
5 注意事项：局部变量名称可以和成员变量名称一样，在方法中使用的时候，采用的是就近原则
（如果局部变量的名字和成员变量的名字相同， 要想在该方法中使用成员变量，必须使用关键字this）

#成员变量和类变量的区别：#

1、两个变量的生命周期不同
?      成员变量随着对象的创建而存在，随着对象的回收而释放。
?       静态变量随着类的加载而存在，随着类的消失而消失。
2、调用方式不同
?      成员变量只能被对象调用。
?      静态变量可以被对象调用，还可以被类名调用。
3、别名不同
?     成员变量也称为实例变量。
?     静态变量也称为类变量。
4、数据存储位置不同
?	成员变量存储在堆内存的对象中，所以也叫对象的特有数据。
?	静态变量数据存储在方法区（共享数据区）的静态区，所以也叫对象的共享数据。
（在jdk8之前，静态成员变量确实是存在在方法区的，但是在jdk8后，取消了“永久代”，取而代之的是“元空间”，
元空间不再使用虚拟内存而是本地内存进行存储，永久代的数据也进行了相关迁移，
常量池和静态成员变量都放到了堆里进行存储）



#spring本质就是一个容器：有三个技术组成IOC(DI),AOP,MVC。#

> IOC(Inversion of Control)：
> 其思想是反转资源获取的方向. 传统的资源查找方式要求组件向容器发起请求查找资源. 作为回应, 容器适时的返回资源. 
> 而应用了 IOC 之后, 则是容器主动地将资源推送给它所管理的组件, 组件所要做的仅是选择一种合适的方式来接受资源. 
> 这种行为也被称为查找的被动形式
> DI(Dependency Injection) 
> ― IOC 的另一种表述方式：
> 即组件以一些预先定义好的方式(例如: setter 方法)接受来自如容器的资源注入. 相对于 IOC 而言，这种表述更直接

## 2.1 IOC:

控制反转，作用是创建对象，管理对象的生命周期，维护对象的关系。由原来的对象依赖对象变为对象依赖容器。
2.1.1 创建对象：以前是我们在java代码new的方式创建对象，现在就交给spring管理，直接在spring的配置文件<bean id="car",class="com.rshz.entity.car">。
2.1.2：spring创建了对象，我们如果得到对象呢：
①得到IOC容器:
ApplicationContext ctx=new ClassPathXmlApplicationContext("ApplicationContext.xml")；
②得到bean:ctx.getBean("car");
③spring集合springmvc以后，直接用注解@AutoWired就可以得到对象bean了。

2.2.1 管理对象的生命周期：分为单例模式（如何实现单例模式：先将构造方法私有化，再创建公共静态的访问方法）；非单例模式。

2.2.2 IOC默认是单例模式，在你还没有实例对象时，程序在启动的时候就会创建一个对象，以后无论实例多少次，都只能得到这一个对象。而非单例模式（prototype，也称原型模式）是在你实例的时候才创建对象，而且你实例多少次就创建多少个对象。


2.3.1 维护对象关系：比如某一个对象的属性是另一个对象，这种关系也交给spring容器管理。有一对多的关系时（一个部门有多个员工）：在一的一方的xml文件配置一个<collection>;有多对一时（多个员工属于一个部门）：在多的一方的xml文件配置一个<association>。

3.1.1 AOP:面向切面编程。把公共的问题写在切面编程上，这样我们就可以专注于我们的业务逻辑就可以了。
3.1.1.1 如何实现AOP：①定义切面编程类：实现事先切入(MethedBeforAdvice),事后切入（afterReturnAdvice）,环绕切入，异常切入（throwsAdvice）等接口。②定义接口，在接口定义一个方法。③定义接口的实现类 ④通过spring  ProxyFactoryBean的代理工厂创建对象：<!-- aop实现 -->
	<bean id="adv" class="com.spring.aop.Advice"></bean>
	<bean id="aqiPlay" class="com.spring.aop.AQIPlay"></bean>
	<!-- 代理工厂 -->
	<bean id="play" class="org.springframework.aop.framework.ProxyFactoryBean">
		<property name="proxyInterfaces">
			<value>com.spring.aop.Play</value>
		</property>
		<property name="interceptorNames">
			<list>
				<value>adv</value>
			</list>
		</property>
		<property name="target" ref="aqiPlay" />
	</bean>。


4.1.1 MVC:也是一种思想，MVC的框架有springMVC，strut1，strut2。

4.1.2 MVC把项目分为视图层（页面展示，相当于jsp），控制层（相当于servlet，负责请求转发，把请求转给模型层，把处理结果转给视图层），模型层（相当于dao层，做业务逻辑和数据库操作）分开设计，便于项目分工。提高代码的重用性，简化客户的请求和响应。

4.1.3 springMVC如何处理流程：用户发送的请求首先被核心控制器（dispatchservlet）拦截，再根据发来的URL分发给具体的处理器（handler）处理，业务逻辑处理完返回一个modelAndView给视图解析器，视图解析器解析，拼接前后缀，视图渲染，再返回给dispatchservlet，流程结束。

6.一级缓存：session，安全。
二级缓存：sessionfactory：不安全，因为共享。





#项目中遇到的问题#

服务器内存溢出：以tomcat为例，找到bin目录的catalina.bat，打开catalina.bat最前面加入set JAVA_OPTS=-Xms128m-Xmx350m   （-Xms  初始堆   -Xmx 最大堆）



1）注意mysql表名和库名是否设置了区分大小写
mysql报表找不到
编辑mysql配置文件：vi /etc/my.cnf
添加：lower_case_table_names=1 一句到文件中。